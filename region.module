<?php

/**
 * Imeplements hook_menu().
 */
function region_menu() {
  $items = array();
  $items['admin/structure/region'] = array(
    'title' => 'Regions',
    'page callback' => 'region_admin',
    'description' => t('Administer regions'),
    'access arguments' => array('administer regions'),
    'file' => 'region.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/structure/region/edit/%region'] = array(
    'title' => 'Edit region',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('region_edit_form', 4),
    'access arguments' => array('edit', 4),
    'access callback' => 'region_access',
    'file' => 'region.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/structure/region/content/%region'] = array(
    'title' => 'Region content',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('region_content_form', 4),
    'access arguments' => array('content', 4),
    'access callback' => 'region_access',
    'file' => 'region.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/structure/region/delete/%region'] = array(
    'title' => 'Delete region',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('region_delete_form', 4),
    'access callback' => 'region_access',
    'access arguments' => array('delete', 4),
    'file' => 'region.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $region_bundles = region_bundles();
  // If we are using the block module, then we add links from there.
  foreach ($region_bundles as $key => $info) {
    $items['admin/structure/region/add/' . $info->name] = array(
      'title' => 'Add ' . drupal_strtolower($info->label),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('region_add_form', 4),
      'access arguments' => array("create {$info->name} entity blocks"),
      'file' => 'region.admin.inc',
      'type' => MENU_LOCAL_ACTION,
    );
  }
  $items['region/autocomplete'] = array(
    'title' => 'region autocomplete',
    'page callback' => 'region_content_form_autocomplete',
    'access callback' => 'user_access',
    'access arguments' => array('administer regions'),
    'type' => MENU_CALLBACK,
    'file' => 'region.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_entity_info().
 */
function region_entity_info() {
  $bundles = region_bundles();
  $bundle_info = array();
  foreach ($bundles as $key => $bundle) {
    $i = 0;
    $bundle_info[$bundle->name] = array(
      'label' => $bundle->label,
      'admin' => array(
        'path' => 'admin/structure/region_bundle/list/%region_bundle/edit',
        'real path' => 'admin/structure/region_bundle/list/' . $bundle->name . '/edit',
        'bundle argument' => 4,
        'access arguments' => array('administer region types'),
      ),
    );
  }
  return array(
    'region' => array(
      'label' => t('Region'),
      'entity class' => 'Region',
      'controller class' => 'EntityAPIController',
      'fieldable' => TRUE,
      'exportable' => TRUE,
      'view modes' => array(
        'block' => array(
          'label' => t('Region'),
          'custom settings' => FALSE,
        ),
      ),
      'access callback' => 'region_access',
      'base table' => 'region_regions',
      'module' => 'region',
      'bundles' => $bundle_info,
      'bundle keys' => array('bundle' => 'name'),
      'entity keys' => array(
        'id' => 'rid',
        'name' => 'name',
        'bundle' => 'bundle',
        'label' => 'title',
      ),
    ),
  );
}

/**
 * Fetch all bundles for a region.
 * @return array
 *   An array of all available bundles.
 */
function region_bundles() {
  ctools_include('export');
  return ctools_export_load_object('region_bundles');
}

/**
 * Load a region bundle
 * @param $name
 *   The name of the bundle.
 * @return stdClass
 *   The actual bundle.
 */
function region_bundle_load($name) {
  ctools_include('export');
  $result = ctools_export_load_object('region_bundles', 'names', array($name));
  return isset($result[$name]) ?  $result[$name] : FALSE;
}

/**
 * Load a region by name
 * @param string $name the name of the region.
 */
function region_load($name) {
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'region')
    ->propertyCondition('name', $name)
    ->execute();
  if (isset($result['region']) && count($result['region'])) {
    return current(entity_load('region', array_keys($result['region'])));
  }
  return FALSE;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function region_ctools_plugin_directory($module, $type) {
  if ($type == 'export_ui') {
    return 'plugins/' . $type;
  }
}

/**
 * Implements hook_ctools_plugin_plugin_type().
 */
function region_ctools_plugin_type() {
  return array(
    'plugins' => array(
      'cache' => TRUE,
      'use hooks' => TRUE,
      'classes' => array('region_storage'),
    ),
  );
}

/**
 * Implements hook_permission().
 */
function region_permission() {
  $permissions = array(
    'administer region types' =>  array(
      'title' => t('Administer region types'),
      'description' => t('Create and delete fields on regions, and set their permissions.'),
    ),
  );
  /*
  // Generate per profile type permissions.
  foreach (entityblock_get_types() as $type) {
    $type_name = check_plain($type->type);
    $permissions += array(
      "create $type_name entity blocks" => array(
        'title' => t('%type_name: Create entity block', array('%type_name' => $type->label)),
      ),
      "edit $type_name entity blocks" => array(
        'title' => t('%type_name: Edit entity block', array('%type_name' => $type->label)),
      ),
      "view $type_name entity blocks" => array(
        'title' => t('%type_name: View entity block', array('%type_name' => $type->label)),
      ),
      "delete $type_name entity blocks" => array(
        'title' => t('%type_name: Delete entity block', array('%type_name' => $type->label)),
      ),
    );
  }
   */
  return $permissions;
}

/**
 * Implements hook_theme().
 */
function region_theme() {
  return array(
    'region_content_form' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Access callback for regions.
 */
function region_access($op, $region, $account = NULL) {
  if (isset($region)) {
    return user_access("$op {$region->bundle} profile", $account);
  }
}

/**
 * Implements hook_block_info().
 */
function region_block_info() {
  $regions = array();
  // Load all blocks
  $regions = entity_load('region');
  foreach ($regions as $region) {
    $blocks[$region->name] = array(
      'info' => $region->title,
      'cache' => $region->cache,
    );
  }
  return $blocks;
}

/**
 * Implements hook_block_configure().
 */
function region_block_configure($delta) {
  $block = entity_load('region', array($delta));
  if (user_access("edit {$block->bundle} entity blocks")) {
    $form_state = array('type' => $block->bundle, 'entityblock' => $block);
    // We attach our entity block form here.
    return entityblock_form(array(), $form_state);
  }
}

/**
 * Implements hook_block_view().
 */
function region_block_view($delta) {
  $block = array();
  // The delta is always the same as the machine name of the
  // entity block, so it's fairly easy to load.
  $region = entity_load('region', array($delta));
  if ($entityblock && user_access("view {$entityblock->type} entity blocks")) {
    $block['subject'] = check_plain($entityblock->title);
    $block['content'] = $entityblock->buildContent();
    return $block;
  }
}

/**
 * Get all storage backends formatted for #options
 * @return array
 *   An array of storage backends.
 */
function region_get_storage_options() {
  $storage_plugins = ctools_get_plugins('region', 'plugins');
  // Get all available storage backends.
  $storage_options = array();
  foreach ($storage_plugins as $name => $info) {
    if (isset($info['title'])) {
      $storage_options[$name] = $info['title'];
    }
  }
  return $storage_options;
}

/**
 * Save the content of a region.
 * @param string $name
 *   The region name
 * @param RegioNode $tree
 *   The tree to save.
 */
function region_save_content($name, $bundle, RegionNode $tree) {
  return region_storage_factory($bundle)->save($name, $tree);
}

function region_append_item($name, $bundle, RegionNode $item) {
  return region_storage_factory($bundle)->appendItem($name, $item);
}

/**
 * Load content for a region.
 * @param string $bundle
 *   The name of the region bundle
 * @param string $name
 *   The name of the region.
 * @return RegionNode the content for a region.
 */
function region_load_content($bundle, $name) {
  return region_storage_factory($bundle)->retrieve($name);
}

/**
 * Factory function for fetching a storage backend for a bundle.
 * @param string $bundle
 * @return RegionStorage a region storage class.
 */
function region_storage_factory($bundle) {
  $bundle = region_bundle_load($bundle);
  $plugin = ctools_get_plugins('region', 'plugins', $bundle->storage);
  return new $plugin['region_storage']['class']();
}

/**
 * This class is used to represent Regions.
 */
class Region extends Entity {
  // We provide the values here for reference.
  public $type;
  public $name;
  public $bid;
  public $title;
  public $content;
  public $cache;

  public function __construct($values = array()) {
    parent::__construct($values, 'region');
    $this->content = new RegionNode();
  }

  /**
   * Gets the type entity.
   *
   * @return Entity
   *  The type associated with this entity.
   */
  public function getTypeEntity() {
    if (isset($this->type)) {
      return entity_get_types($this->type);
    }
  }

  /**
   * Build content.
   * @param string $view_mode
   *   The current view mode.
   * @param type $langcode
   *   The language code to use.
   * @return array
   *  An array that can be used with Drupals rendering system.
   */
  public function buildContent($view_mode = 'block', $langcode = NULL) {
    $content = array();
    return entity_get_controller($this->entityType)->buildContent($this, $view_mode, $langcode, $content);
  }

  public function getTree() {
    return $this->content;
  }
}

class RegionNode {
  public $type;
  public $entity_id;
  public $key;
  public $parent;
  public $content;
  public $view_mode;
  private $children = array();

  public function __construct($type = NULL, $entity_id = NULL, $content = NULL, $view_mode = NULL) {
    $this->type = $type;
    $this->entity_id = $entity_id;
    $this->content = $content;
    $this->view_mode = $view_mode;
  }

  /**
   * Add a child to this node. This is a helper for addChildNode.
   * @param string $name
   * @param stdClass $content
   */
  public function addChild($type, $entity_id, $content, $view_mode = NULL, $key = NULL) {
    $node = new RegionNode($type, $entity_id, $content, $view_mode);
    if (isset($key)) {
      $node->key = $key;
    }
    $node->parent = $this;
    $this->addChildNode($node);
  }

  /**
   * Add a node as a child to this one.
   * @param RegionNode $child
   */
  public function addChildNode(RegionNode $child) {
    if (!isset($this->children)) {
      $this->children = array();
    }
    if (!isset($child->key)) {
      $child->key = $this->getLastChildKey();
    }
    $this->children[$child->key] = $child;
  }

  public function removeChild($name) {
    unset($this->children[$child->name]);
  }

  public function getChild($key) {
    // Return the child if it exists.
    if (isset($this->children[$key])) {
      return $this->children[$key];
    }
    // Return FALSE if this branch has no children.
    if (!count($this->children)) {
      return FALSE;
    }
    foreach ($this->children as $node) {
      $result = $node->getChild($key);
      if (!empty($result)) {
        return $result;
      }
    }
    return FALSE;
  }

  public function getLastChild() {
    return $this->children[count($this->children)-1];
  }

  public function getLastChildKey() {
    $keys = array_keys($this->children);
    if (count($keys)) {
      return $keys[count($keys)-1];
    }
    return -1;
  }

  public function truncate() {
    $this->children = array();
  }

  public function getChildren() {
    return $this->children;
  }

  /**
   * Return this node as an array.
   */
  public function toArray() {
    $tree = array();
    foreach ($this->children as $key => $child) {
      $tree[$key]['content'] = $child->content;
      $tree[$key]['children'] = $child->toArray();
    }
    return $tree;
  }
}
